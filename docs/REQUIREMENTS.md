## 1. Обзор и границы
- Цель: дать возможность двум вкладкам/браузерам зайти в одну комнату, по очереди сделать по одному полноценному ходу (до 3 бросков с удержанием) и записать результат.
- Вне рамок: долговременные таблицы и статистика, авторизация.

## 2. Функциональные требования (FR)
- FR‑1 (GUI): Кнопка «Бросить», отображение 5 костей, счётчик оставшихся бросков (3→0), переключение удержания кликом.
- FR‑2 (Правила хода): Не более 3 бросков за ход; бросок меняет только не удержанные кости.
- FR‑3 (Подсчёт): Для текущих 5 костей отображаются очки этапа 1 (ones..sixes).
- FR‑4 (Запись): Игрок выбирает одну категорию этапа 1 и записывает результат; повторная запись в ту же категорию запрещена.
- FR‑5 (Комнаты):
  - Создание комнаты → код/ссылка комнаты.
  - Присоединение по коду (минимум 2 игрока, максимум 4 для демо).
- FR‑6 (Онлайн‑синхронизация):
  - Сервер — источник истины: броски, право хода и запись очков валидируются на сервере.
  - События через Socket.IO: `room:join`, `turn:roll`, `turn:holdToggle`, `turn:commit`, `state:sync`.
  - Порядок ходов: круговой по списку игроков комнаты.
- FR‑7 (Завершение мини‑партии): После того как каждый игрок сделал по одному ходу с записью результата, мини‑партия завершается (показываем список результатов). Повторный запуск — кнопка «Новая мини‑партия» (сброс состояния комнаты).

## 3. Нефункциональные требования (NFR)
- NFR‑1: Chrome‑only для демо.
- NFR‑2: Отклик локальных действий — < 100 мс; сетевые обновления — как позволяет сеть, UI должен явно отражать ожидание (disabled кнопки/спиннер на броске).
- NFR‑3: In‑memory серверное хранилище на одну ноду; поддержка до 10 комнат и до 4 игроков в комнате.
- NFR‑4: Минимальная честность: броски генерируются на сервере; клиент не может бросить при чужом ходе.
- NFR‑5: Простые юнит‑тесты: минимум 3 теста на формулу этапа 1 и 1 тест на REST `/api/health` сервера.

## 4. Ограничения и предположения
- Клиент: Vanilla JS + HTML/CSS (без сборки) + socket.io-client через CDN; Сервер: Python FastAPI + python‑socketio; Pydantic для валидации полезных нагрузок.
- Серверные события: `state:sync` рассылается всем в комнате после каждого действия.
- Без персистентности между рестартами.
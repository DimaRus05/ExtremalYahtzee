## 1. Обзор и границы
- Цель: минимально жизнеспособная веб‑версия «Покера на костях» с комнатами, поочередными ходами и подсчётом очков. Два и более клиента (2–4 игрока) подключаются к одной игре и делают ходы по кругу.
- Серверная логика и состояние игры — в памяти процесса (in‑memory), без персистентности и без авторизации.
- Вне рамок: долговременные таблицы/статистика, аккаунты, Socket.IO (используется опрос состояния), БД.

## 2. Функциональные требования (FR)
- FR‑1 (Комнаты и лобби):
  - Создание игры с параметрами: `max_players` (<=4), `max_rounds` (>=1).
  - Присоединение по `game_id`; имена игроков уникальны в пределах игры.
  - Старт игры возможен при 2+ игроках и готовности всех (флаг `is_ready`).

- FR‑2 (Ход и броски):
  - В начале хода текущему игроку автоматически бросаются 5 костей.
  - За ход доступно до 3 бросков: первичный + до 2 перебросов.
  - Переброс задаётся массивом индексов костей `[0..4]`; только указанные индексы меняются.
  - Сервер валидирует статус игры, право хода, лимит перебросов и корректность индексов.

- FR‑3 (Подсчёт очков):
  - Используются покерные комбинации: Пять одинаковых, Четыре одинаковых, Фулл‑хаус, Стрит (1–5 или 2–6), Три одинаковых, Две пары, Одна пара, Старшая кость.
  - Таблица очков: 100 / 40 / 25 / 20 / 15 / 10 / 5 / значение старшей кости.

- FR‑4 (Завершение хода):
  - При `end_turn` комбинация определяется на сервере и очки начисляются игроку.
  - Ход сохраняется в историю (игрок, кости, комбинация, очки, раунд, время).

- FR‑5 (Раунды и завершение):
  - Порядок ходов — круговой по списку игроков.
  - После хода последнего игрока раунд увеличивается на 1; при `current_round > max_rounds` игра завершена.
  - Победитель — игрок с максимальным счётом.

- FR‑6 (Состояние игры):
  - Эндпоинт `GET /game/<game_id>/state` возвращает: `game_id`, `status`, `current_round`, `max_rounds`, список игроков (id, name, score, is_ready, is_current), текущее состояние хода (бросок, оставшиеся перебросы, комбинация при активности), `winner` при завершении.

## 3. Нефункциональные требования (NFR)
- NFR‑1: In‑memory хранение на одну ноду; отсутствие персистентности между рестартами.
- NFR‑2: Обновление UI — опрос состояния через HTTP; realtime‑сокеты не используются.
- NFR‑3: До 4 игроков в одной игре; количество игр ограничено ресурсами процесса.
- NFR‑4: Простые интеграционные/юнит‑тесты (pytest) для ядра и эндпоинтов.

## 4. Ограничения и предположения
- Сервер: Python Flask; клиент: шаблоны Jinja2 + Vanilla JS/CSS.
- «Удержания» костей не хранятся на сервере — клиент передаёт индексы костей для переброса.
- Имена игроков уникальны в пределах игры; превышение `max_players` запрещено.
- Генерация бросков — `random.randint(1,6)` (не криптостойкая).

## 5. API (сводка)
- `POST /create_game` — создать игру (возвращает `game_id`).
- `POST /join_game` — присоединиться по `game_id`, получить `player_id` и состояние.
- `POST /game/<id>/ready` — отметить готовность; старт при готовности всех.
- `GET /game/<id>/state` — получить состояние игры для текущего игрока.
- `POST /game/<id>/reroll` — перебросить выбранные индексы костей.
- `POST /game/<id>/end_turn` — завершить ход.
- `POST /game/<id>/leave` — покинуть игру и очистить сессию.

Подробности: см. `docs/API documentation.md`.